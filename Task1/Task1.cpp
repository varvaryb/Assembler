// Задача 1 (5 вар.): указать те символы, которые есть и в первой и во второй строке.

#include <iostream>

int main()
{
    setlocale(0, "rus");
    const int N = 255;
    char res[N];
    char vvod1[] = "Введите первую строку\n";
    char vvod2[] = "\nВведите вторую строку\n";
    char ns[] = "Данные строки не имеют общих символов";
    char str1[N];
    char str2[N];
    __asm
    {
        // считываем строки
        lea     eax, vvod1      ; поместили в eax адрес на vvod1 
        push    eax             ; закинули eax в стэк для дальнейшего вывода 
        call    printf          ; вывели vvod1
        add     esp, 4          ; очистили стэк

        mov     eax, N
        push    eax
        lea     eax, str1
        push    eax 
        call    gets_s          ; считали строку str1 
        add     esp, 8

        lea     eax, vvod2
        push    eax
        call    printf          ; вывели vvod2
        add     esp, 4          ; очистили стэк

        mov     eax, N
        push    eax
        lea     eax, str2
        push    eax 
        call    gets_s          ; считали строку str2 
        add     esp, 8

        lea     edx, str2       ; сохранили адрес строки str2 
        lea     ebx, str1       ; сохранили адрес строки str1

        xor     eax, eax        ; обнуляем eax
        xor     edi, edi        ; в edi количество совпавших элементов

START:                          ; главный цикл

        xor     esi, esi        ; esi - текущий счетчик
        mov     cl, [ebx][eax]  ; положили в cl первый символ первой строки
        inc     eax             ; увеличили счетчик (индекс символа в str1)
        cmp     cl, 0           ; проверка конца строки
        je      NEW_RES         ; ушли на вывод результата, если строка закончилась 

START2:                         ; взяли символ str1 и сравниваем его с каждым символом str2 

        mov     ch, [edx][esi]  ; положили в ch следующий символ str2
        cmp     ch, 0           ; проверка конца строки
        je      END             ; ушли в обнуление текущего счетчика, если строка закончилась,
                                ; чтобы делать дальнейшие сравнения со следующим символом str1

        cmp     cl, ch          ; сравнили символы
        je      FOUND           ; если символы совпали - говорим нашли
        inc     esi             ; если нет - увеличили текущий счётчик
        jmp     START2          ; и проверяем следующий символ str2

END:
        jmp     START           ; возвращаемся в главный цикл

FOUND:
        mov     [res][edi], cl  ; поместили в res совпавший символ 
        inc     edi             ; увеличили счетчик совпавших символов
        jmp     START           ; ушли в главный цикл
    
NEW_RES:
        cmp     edi, 0          ; проверяем, есть ли совпавшие символы
        je      NOT_SOVP        
 
        mov     [res][edi], 0   ; добавляем 0 в качестве конца строки 
        jmp     PRINT_RES

NOT_SOVP:
        lea     eax, ns
        push    eax
        call    printf          ; вывели, что нет совпадений
        add     esp, 4
        jmp     EXIT

PRINT_RES:
        lea     eax, res
        push    eax 
        call    printf
        add     esp, 4
EXIT:
    }
    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.